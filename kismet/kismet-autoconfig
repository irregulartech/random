#!/bin/sh
set -e
set -u

# airmon-ng doesn't work without root
if [ -x "$(command -v id 2> /dev/null)" ]; then
	USERID="$(id -u 2> /dev/null)"
fi

if [ -z "${USERID}" ] && [ -n "$(id -ru)" ]; then
	USERID="$(id -ru)"
fi

if [ -n "${USERID}" ] && [ "${USERID}" != "0" ]; then
	printf 'Run it as root\n' ; exit 1;
elif [ -z "${USERID}" ]; then
	printf 'Unable to determine user id, permission errors may occur.\n'
fi

VERS="v1.2"

blue_hydra="false"
rtl_skip_zero="false"
trigger_lar="true"
log_location=""
truncate_data="false"

if [ ! -x "$(command -v airmon-ng 2>&1)" ]; then
  printf 'airmon-ng is required, please install it\n' >&2
  printf 'this tool is typically available in the "aircrack-ng" package\n' >&2
  exit 1
fi
if [ ! -x "$(command -v ss 2>&1)" ]; then
  printf 'ss is required, please install it\n' >&2
  printf 'this tool is typically available in the "ss" package\n' >&2
  exit 1
fi
if [ ! -x "$(command -v jq 2>&1)" ]; then
  printf 'jq is required, please install it\n' >&2
  printf 'this tool is typically available in the "jq" package\n' >&2
  exit 1
fi
# maybe add support for ncat from nmap?
if [ ! -x "$(command -v nc 2>&1)" ]; then
  printf 'Some kind of netcat is required as "nc", please install it\n' >&2
  printf 'this tool is typically available in the "netcat" package\n' >&2
  exit 1
else
  # this doesn't support gnu netcat which needs -c?
  if nc -h 2>&1 | grep -q -- '-N'; then
    nc_flags="-N"
  elif nc -h 2>&1 | grep -q -- '-q'; then
    nc_flags="-q1"
  else
    nc_flags=""
  fi
fi

#argparser
while [ -n "${1:-}" ]; do
  case ${1} in 
    --blue_hydra)
      blue_hydra="true"
      shift
      ;;
    --log-location)
      shift
      log_location="${1}"
      shift
      ;;
    --rtl-skip-zero)
      rtl_skip_zero="true"
      shift
      ;;
    --skip-lar)
      trigger_lar="false"
      shift
      ;;
    --truncate-data)
      truncate_data="true"
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
  esac
done

if [ -n "${1:-}" ]; then
  if ! touch "${1}" || [ ! -w "${1}" ]; then
    printf 'Unable to write to config %s\n' "${1}" >&2
    exit 1
  else
    if [ "$(awk -F. '{print $1}' /proc/uptime)" -lt 60 ]; then
      sleepy_tyme=$(( 60 - $(awk -F. '{print $1}' /proc/uptime) ))
      printf 'Sleeping for %s seconds before writing config...\n' "${sleepy_tyme}" >&2
      sleep "${sleepy_tyme}"
    fi
  fi
fi

if [ -n "${log_location:-}" ]; then
  if [ ! -d "${log_location}" ]; then
    printf 'WARN: Requested log location %s does not exist, creating...\n' "${log_location}"
    mkdir -p "${log_location}"
  fi
  if [ ! -w "${log_location}" ]; then
    printf 'FATAL: Unable to write to requested log location: %s\n' "${log_location}" >&2
    exit 1
  fi
fi

kismet_site=${1:-/dev/stdout}
printf 'kismet-autoconfig %s writing to %s\n' "${VERS}" "${kismet_site}" >&2

printf '## WARNING: This file is generated by kismet-autoconfig and cannot be edited!!!\n' > "${kismet_site}"

detect_nxp() {
  nxp_usb="$(lsusb -d '15a2:0300' | wc -l)"
  if [ "${nxp_usb}" = "0" ]; then
    return 0
  fi
  nxp_serial="0"
  all_nxp_accounted="0"
  [ "${ZSH_NAME:-}" = "zsh" ] && unsetopt nomatch
  for nxp in /dev/nxp_kw41z* ; do
    if [ "${nxp}" = "/dev/nxp_kw41z*" ]; then
      continue
    fi
    printf '\n## NXP_KW1Z btle and zigbee sniffer\n' >> "${kismet_site}"
    printf 'source=nxp_kw41z:device=%s,type=nxp_kw41z,phy=all\n' "${nxp}" >> "${kismet_site}"
    : $(( nxp_serial += 1 ))
  done
  [ "${ZSH_NAME:-}" = "zsh" ] && setopt nomatch
  if [ "${nxp_usb}" != "${nxp_serial}" ]; then
    printf 'Detected %s nxp_kw1z but found serial interfaces for %s.\n' "${nxp_usb}" "${nxp_serial}"
    all_nxp_accounted="1"
    if [ "${nxp_serial}" = 0 ]; then
      printf 'Did you forget to install kismet/packaging/udev/99-kismet-nxp-kw41z.rules?\n'
    fi
  fi
  return "${all_nxp_accounted}"
}

detect_nordic() {
  all_nrf_accounted="0"
  mousejack_first="1"
  nrf154a_usb="0"
  nrf522a_usb="0"
  nrf154a_serial="0"
  nrf522a_serial="0"

  IFS='
'
  for device in \
    $(lsusb -d '1915:' | tr ":" " "| awk '{print $6":"$7,$2"-"$4}' | sort) \
    $(lsusb -d '239a:' | tr ":" " "| awk '{print $6":"$7,$2"-"$4}' | sort)
    do
    VID="$(printf '%s' "${device}" | awk '{print $1}' | awk -F: '{print $1}')"
    PID="$(printf '%s' "${device}" | awk '{print $1}' | awk -F: '{print $2}')"
    BUS="$(printf '%s' "${device}" | awk '{print $2}')"
    case "${PID}" in
      0102)
        # Nordic Semiconductor ASA Research Firmware
        if [ "${mousejack_first}" = "1" ]; then
          printf '\n## mousejack\n' >> "${kismet_site}"
          mousejack_first="0"
        fi
        printf 'source=mousejack-%s:hop_rate=82/sec,type=nrfmousejack\n' "${BUS}" >> "${kismet_site}"
        ;;
      154a)
        # nrf51822 802.15.4 sniffer
        # needs to be found by /dev/nrf51822*
        : $(( nrf154a_usb += 1 ))
        ;;
      522a)
        # nrf52840 ble sniffer
        # needs to be found by /dev/nrf52840*
        : $(( nrf522a_usb += 1 ))
        ;;
      7777)
        printf 'Detected stock Crazyradio PA dongle, did you forget to flash the rfstorm firmware?\n'
        all_nrf_accounted="1"
        ;;
      *)
        printf 'Detected unsupported nrf device %s:%s, did you forget to flash the correct firmware?\n' "${VID}" "${PID}"
        all_nrf_accounted="1"
        ;;
    esac
  done
  unset IFS

  nrf51822_first="1"
  [ "${ZSH_NAME:-}" = "zsh" ] && unsetopt nomatch
  for nrf51822 in /dev/nrf51822*; do
    if [ "${nrf51822}" = "/dev/nrf51822*" ]; then
      continue
    fi
    if [ "${nrf51822_first}" = "1" ]; then
      printf '\n## nrf51822 802.15.4 sniffer\n' >> "${kismet_site}"
      nrf51822_first="0"
    fi
    printf 'source=nrf51822:device=%s,type=nrf51822\n' "${nrf51822}" >> "${kismet_site}"
    nrf154a_serial=$(( nrf154a_serial + 1 ))
  done
  [ "${ZSH_NAME:-}" = "zsh" ] && setopt nomatch
  if [ "${nrf154a_usb}" != "${nrf154a_serial}" ]; then
    printf 'Detected %s nrf51822 but found serial interfaces for %s.\n' "${nrf154a_usb}" "${nrf154a_serial}"
    all_nrf_accounted="1"
    if [ "${nrf154a_serial}" = 0 ]; then
      printf 'Did you forget to install kismet/packaging/udev/99-kismet-nrf51822.rules?\n'
    fi
  fi

  nrf52840_first="1"
  [ "${ZSH_NAME:-}" = "zsh" ] && unsetopt nomatch
  for nrf52840 in /dev/nrf52840*; do
    if [ "${nrf52840}" = "/dev/nrf52840*" ]; then
      continue
    fi
    if [ "${nrf52840_first}" = 1 ]; then
      printf '\n## nrf52840 ble sniffer\n' >> "${kismet_site}"
      nrf52840_first="0"
    fi
    printf 'source=nrf52840:device=%s,type=nrf52840\n' "${nrf52840}" >> "${kismet_site}"
    nrf522a_serial=$(( nrf522a_serial + 1 ))
  done
  [ "${ZSH_NAME:-}" = "zsh" ] && setopt nomatch
  if [ "${nrf522a_usb}" != "${nrf522a_serial}" ]; then
    printf 'Detected %s nrf52840 but found serial interfaces for %s.\n' "${nrf522a_usb}" "${nrf522a_serial}"
    all_nrf_accounted="1"
    if [ "${nrf522a_serial}" = 0 ]; then
      printf 'Did you forget to install kismet/packaging/udev/99-kismet-nrf52840.rules?\n'
    fi
  fi

  return "${all_nrf_accounted}"
}

detect_linuxbluetooth() {
  if [ -x "$(command -v hciconfig)" ]; then
    bthci="$(hciconfig -a | awk -F: '/hci/{print $1}')"
    if [ -n "${bthci}" ]; then
      printf '\n## bluetooth classic *active* discovery\n' >> "${kismet_site}"
      for hci in ${bthci}; do
        if [ "${hci}" = "hci0" ] && [ "${blue_hydra}" = "true" ]; then
          continue
        fi
        printf 'source=%s:type=linuxbluetooth\n' "${hci}" >> "${kismet_site}"
      done
    fi
  else
    printf 'Bluetooth detection unavailable, hciconfig not installed.\n' >&2
    printf 'Typically this package is available as "bluez"\n' >&2
    printf '\n## Bluetooth detection unavailable, hciconfig not installed.\n' > "${kismet_site}"
    return 1
  fi
  return 0
}

detect_ubertooth() {
  if [ -z "$(lsusb -d '1d50:6002' 2>&1)" ]; then
    # No ubertooth found, bail out quick
    return 0
  fi
  if [ ! -x "$(command -v ubertooth-util)" ]; then
    printf 'Ubertooth device found using lsusb, but ubertooth tools are not installed\n' >&2
    printf 'Typically this package is available as "ubertooth".\n' >&2
    printf '# Ubertooth found, but ubertooth tools are not installed and are required.\n' > "${kismet_site}"
    return 1
  fi
  uberteeth="$(ubertooth-util -N 2>/dev/null)"
  if [ "${uberteeth}" -gt "0" ]; then
    ubertooth_errors="0"
    printf '\n## btle passive discovery using ubertooth\n' >> "${kismet_site}"
    for i in $(seq 1 "${uberteeth}"); do
      ubertooth_device=$((i-1))
      if [ "${ubertooth_device}" = "1" ] && [ "${blue_hydra}" = "true" ]; then
        printf 'Ubertooth %s detected but left for blue_hydra\n' "${ubertooth_device}" >&2
        printf '# Leaving ubertooth %s for blue_hydra\n' "${ubertooth_device}" >> "${kismet_site}"
        printf '# source=ubertooth-%s:type=ubertooth\n' "${ubertooth_device}" >> "${kismet_site}"
        continue
      fi
      if ubertooth_rx_stderr="$(ubertooth-rx -z -t 1 -U "${ubertooth_device}" 2>&1 > /dev/null)"; then
        printf 'source=ubertooth-%s:type=ubertooth\n' "${ubertooth_device}" >> "${kismet_site}"
      else
        if [ -n "${ubertooth_rx_stderr}" ]; then
          if printf '%s' "${ubertooth_rx_stderr}" | grep -q 'Access denied'; then
            printf 'Ubertooth detected but user %s does not have access to ubertooth %s hardware\n' "$(id -un)" "${ubertooth_device}" >&2
            printf '# ubertooth-%s skipped due to permission error\n' "${ubertooth_device}" >> "${kismet_site}"
            printf '# source=ubertooth-%s:type=ubertooth\n' "${ubertooth_device}" >> "${kismet_site}"
            ubertooth_errors="1"
          fi
          if printf '%s' "${ubertooth_rx_stderr}" | grep -q 'Please upgrade to latest released firmware'; then
            printf 'Ubertooth %s detected but requires a firmware upgrade to work.\n' "${ubertooth_device}" >&2
            printf '# ubertooth-%s skipped due to required firmware upgrade\n' "${ubertooth_device}" >> "${kismet_site}"
            printf '# source=ubertooth-%s:type=ubertooth\n' "${ubertooth_device}" >> "${kismet_site}"
            ubertooth_errors="1"
          fi
        else
          printf 'Ubertooth test command "ubertooth-rx -z -t 1 -U %s" failed, without output.\n' "${i}" >&2
          printf 'You are on your own to figure out why.\n' >&2
          printf '# ubertooth-%s skipped due to unknown failure\n' "${ubertooth_device}" >> "${kismet_site}"
          ubertooth_errors="1"
        fi
        continue
      fi
    done
    return "${ubertooth_errors}"
  fi
  return 0
}

detect_ti() {
  ti16ae_first="1"
  ti16b3_first="1"
  IFS='
'
for device in $(lsusb -d '0451:' | tr ":" " "| awk '{print $6":"$7,$2"-"$4}' | sort); do
  PID="$(printf '%s' "${device}" | awk '{print $1}' | awk -F: '{print $2}')"
  BUS="$(printf '%s' "${device}" | awk '{print $2}')"
  case "${PID}" in
    16ae)
      #Texas Instruments, Inc. CC2531 Dongle
      if [ "${ti16ae_first}" = "1" ]; then
        printf '\n## ticc2531 zigbee\n' >> "${kismet_site}"
        ti16ae_first=0
      fi
      printf 'source=ticc2531-%s:type=ticc2531\n' "${BUS}" >> "${kismet_site}"
      ;;
    16b3)
      #Texas Instruments, Inc. CC2540 USB Dongle
      if [ "${ti16b3_first}" = "1" ]; then
        printf '\n## ticc2540 btle\n' >> "${kismet_site}"
        ti16b3_first="0"
      fi
      printf 'source=ticc2540-%s:type=ticc2540\n' "${BUS}" >> "${kismet_site}"
      ;;
  esac
done
unset IFS
return 0
}

detect_rtl() {
  #make sure we kill any left over rtl_433
  if pkill rtl_433 > /dev/null 2>&1; then
    sleep 1
    if pkill -9 rtl_433 > /dev/null 2>&1; then
      sleep 1
    fi
  fi
  rtl_num_devices=$(rtl_eeprom 2>&1 >/dev/null | grep "Found [0-9][0-9]*" | sed -E 's/.*([0-9]+).*/\1/')
  if [ -n "${rtl_num_devices}" ]; then
    printf "\n## RTL-SDR type sources\n" >> "${kismet_site}"
    for i in $(seq 1 "${rtl_num_devices}"); do
      rtl_device=$((i-1))
      if [ "${rtl_skip_zero}" = "true" ]; then
        case ${rtl_device} in
          0) printf 'Skipping rtlsdr-0 by request\n' >&2
            printf '# rtlsdr-%s detected but skipped by request\n' "${rtl_device}" >> "${kismet_site}"
            printf '# source=rtl433-%s:type=rtl433\n' "${rtl_device}" >> "${kismet_site}"
            continue
            ;;
          1) freq="433.92" ;;
          2) freq="315" ;;
          3) freq="915" ;;
          4) freq="345" ;;
          5) freq="868.3" ;;
          6) freq="adsb" ;;
          7) freq="amr" ;;
          *) freq="none" ;;
        esac
      else
        case ${rtl_device} in
          0) freq="433.92" ;;
          1) freq="315" ;;
          2) freq="915" ;;
          3) freq="345" ;;
          4) freq="868.3" ;;
          5) freq="adsb" ;;
          6) freq="amr" ;;
          *) freq="none" ;;
        esac
      fi
      printf '# rtl-sdr %s\n' "${rtl_device}" >> "${kismet_site}"
      if [ "${freq}" = "none" ]; then
        printf 'You have more rtlsdrs than we know what to do with.\n' >&2
        printf '# Wasting rtlsdr-%s\n' "${rtl_device}" >> "${kismet_site}"
      elif [ "${freq}" = "adsb" ]; then
        printf 'source=rtladsb-%s:name=rtladsb,type=rtladsb\n' "${rtl_device}" >> "${kismet_site}"
      elif [ "${freq}" = "amr" ]; then
        printf 'source=rtlamr-%s:name=rtlamr,type=rtlamr\n' "${rtl_device}" >> "${kismet_site}"
      else
        printf 'source=rtl433-%s:channel=%sMHz,name=rtl%s,type=rtl433\n' "${rtl_device}" "${freq}" "${freq}" >> "${kismet_site}"
      fi
    done
  fi
  return 0
}

detect_linuxwifi() {
  # Hak5 Coconut
  coconut_found="0"
  coconuts="$(kismet_cap_hak5_wifi_coconut --list 2>&1 | awk '/^ *coconut/ {print $1}')"
  if [ -n "${coconuts}" ]; then
    coconut_found="1"
    printf '\n## Hak5 Wifi Coconut\n' >> "${kismet_site}"
    for coconut in ${coconuts}; do
      printf 'source=%s\n' "${coconut}" >> "${kismet_site}"
    done
  fi

  # XXX: the coconut detection needs to remove things from the wlan detection, and it's a little dumb about it

  wlan_devices="$(airmon-ng | grep --color=never phy | awk '{print $2}')"
  if [ -n "${wlan_devices:-}" ]; then
    printf '\n## Wifi\n' >> "${kismet_site}"
    for wlan in ${wlan_devices}; do
      if [ "${trigger_lar}" = "true" ]; then
        if [ -r "/sys/class/net/${wlan}/device/uevent" ]; then
          DRIVER="$(awk -F'=' '$1 == "DRIVER" {print $2}' "/sys/class/net/${wlan}/device/uevent")"
          if [ -n "${DRIVER:-}" ]; then
            if [ "${DRIVER}" = "rt2800usb" ] && [ "${coconut_found}" = "1" ]; then
              printf 'Ignoring individual rt2800usb device %s because Hak5 Coconut present.\n' "${wlan}" >&2
              printf '# Ignoring individual rt2800usb device %s because Hak5 Coconut present.\n' "${wlan}" >> "${kismet_site}"
              continue
            elif [ "${DRIVER}" = "iwlwifi" ]; then
              # This isn't as robust as airmon-ng but I don't think I care since it works for iwlwifi
              if [ -r "/sys/class/net/${wlan}/phy80211/name" ]; then
                PHYDEV="$(cat "/sys/class/net/${wlan}/phy80211/name")"
                if [ -n "${PHYDEV:-}" ]; then
                  # If channel 5955 isn't enabled then we know we need to scan
                  # Channel 5955 was chosen because most countries allow 5945 and higher
                  # https://git.kernel.org/pub/scm/linux/kernel/git/wens/wireless-regdb.git/tree/db.txt
                  if iw phy "${PHYDEV}" channels | grep -q '5955 MHz .* (disabled)' > /dev/null 2>&1 ; then
                    [ "${ZSH_NAME:-}" = "zsh" ] && unsetopt nomatch
                    for vif in /sys/class/ieee80211/"${PHYDEV}"/device/net/*; do
                      # Checking for managed/client mode
                      if [ "$(cat "${vif}/type")" = "1" ]; then
                        vif_name="${vif##*/}"
                        was_down="0"
                        if ! ip link show "${vif_name}" | grep -q 'UP' > /dev/null 2>&1 ; then
                          ip link set "${vif_name}" up >&2
                          was_down="1"
                        fi
                        iw "${vif_name}" scan > /dev/null 2>&1
                        sleep 1
                        if [ "${was_down}" = "1" ]; then
                          ip link set "${vif_name}" down >&2
                        fi
                      fi
                    done
                    [ "${ZSH_NAME:-}" = "zsh" ] && setopt nomatch
                  fi
                fi
              fi
            fi
          fi
        fi
      fi
      if [ "${truncate_data}" = "false" ]; then
        printf 'source=%s:default_ht20=true,type=linuxwifi\n' "${wlan}" >> "${kismet_site}"
      else
        printf 'source=%s:default_ht20=true,truncate_data=true,type=linuxwifi\n' "${wlan}" >> "${kismet_site}"
      fi
    done
  fi
  return 0
}

detect_gps() {
  printf '\n## gps\n'
  if ss -nlt 2>&1 | grep -q '127.0.0.1:2947'; then
    gps_device="false"
    for gps in $(printf '?DEVICES;' | timeout 1 nc ${nc_flags:-} localhost 2947 2>&1 | jq -eM 'select (.class=="DEVICES") | ."devices"[]."path"'); do
      printf '# Found GPS device %s controlled by gpsd\n' "${gps}" >> "${kismet_site}"
      gps_device="true"
    done
    if [ "${gps_device}" = "true" ]; then
      gps_lock="0"
      for lock in $(printf '?WATCH={"json":true,"nmea":true};\n?POLL;' |  nc ${nc_flags:-} localhost 2947 2>&1 | jq -eM 'select (.class=="POLL").tpv[]."mode"'); do
        case "${lock}" in
          0) true ;;
          1) [ "${gps_lock}" -lt 1 ] && gps_lock="1";;
          2) [ "${gps_lock}" -lt 2 ] && gps_lock="2";;
          3) [ "${gps_lock}" -lt 3 ] && gps_lock="3";;
          *) printf 'Unknown gps lock state %\n' "${lock}" >&2
        esac
      done
      case "${gps_lock}" in
        # pgrep -a gpsd | grep -q -- ' -n '
        0) printf 'GPS lock is unknown, are you sure your gps works?\n' ;;
        1) printf 'GPS has no lock, consider adding "-n" to GPSD_OPTIONS\n' ;;
        2) printf 'Best gps lock is 2d, consider adding "-n" to GPSD_OPTIONS\n' ;;
        3) true ;;
        *) true ;;
      esac
      printf 'gps=gpsd:host=localhost,port=2947,reconnect=true\n' >> "${kismet_site}"
    else
      printf 'GPSD is running but no devices are configured, please configure gpsd to use your gps if you want location information.\n' >&2
      printf '# gpsd is running but no devices are configure, please configure gpsd to use your gps if you want location information.\n' >> "${kismet_site}"
      printf '# gps=gpsd:host=localhost,port=2947,reconnect=true\n' >> "${kismet_site}"
      return 1
    fi
  else
    printf 'GPSD is not running, please configure and start it if you want location information.\n' >&2
    printf '# gpsd is not running, please configure and start it if you want location information.\n' >> "${kismet_site}"
    printf '# gps=gpsd:host=localhost,port=2947,reconnect=true\n' >> "${kismet_site}"
    return 1
  fi
  return 0
}

add_log_details() {
  printf '\n## logging config\n' >> "${kismet_site}"
  printf 'log_title=%s\n' "$(hostname)" >> "${kismet_site}"

  if [ -n "${log_location:-}" ]; then
    printf '# log location\n' >> "${kismet_site}"
    printf 'log_prefix=%s\n' "${log_location}" >> "${kismet_site}"
  fi
  return 0
}

add_user_config() {
  if [ -r "/etc/kismet/kismet-autoconfig.conf" ]; then
    cat /etc/kismet/kismet-autoconfig.conf >> "${kismet_site}"
  elif [ -r "/usr/local/kismet/kismet-autoconfig.conf" ]; then
    cat /usr/local/kismet/kismet-autoconfig.conf >> "${kismet_site}"
  fi
  return 0
}

kick_it() {
  errors_found="0"
  detect_nxp || errors_found="1"
  detect_nordic || errors_found="1"
  detect_linuxbluetooth || errors_found="1"
  detect_ubertooth || errors_found="1"
  detect_ti || errors_found="1"
  detect_rtl || errors_found="1"
  detect_linuxwifi || errors_found="1"
  detect_gps || errors_found="1"
  add_log_details || errors_found="1"
  add_user_config || errors_found="1"
  return "${errors_found}"
}

if kick_it; then
  exit 0
else
  printf '%s found likely errors, please review the output carefully.\n' "${0}"
  exit 1
fi
